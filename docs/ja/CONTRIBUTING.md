# 貢献

ワームホールは、寛容なApache2ライセンスの下でライセンスされたオープンソースプロジェクトです。貢献は大いに
感謝し、迅速に見直されます。

ワームホールは、ミッションクリティカルなハイステークスプロジェクトです。量より質を最適化します。設計プロセス
コードレビューは、それを達成するための最も重要なツールです。

-すべての新機能は、実装を開始する前に、まずGitHubの問題で説明する必要があります。にとって
  複雑な機能の場合は、[正式な設計ドキュメント](design/template.md)を提出すると便利です。

-開発は長期的な開発ブランチで行われます(通常、大きな変更の場合は `main`または` dev。<x> `)。
  開発ブランチに入るすべての変更は、個別にレビューされます(以下を参照)。分岐した分岐を解放します
  from `main`は、ワームホールの実際のリリースをサポートするために使用されます。最大2つのリリースをサポートすることを目指しています
  同時に分岐します。開発ブランチからリリースブランチへの変更を厳選することができますが、
  リリースブランチから開発ブランチへの移行はありません。
  
-リリースは最初にテストネットでテストされます。これには、ノードを実行しているメインネットDAOとの調整が含まれます。

-コミットは小さく、意味のあるコミットメッセージを含める必要があります。 1つのコミットは、大まかに言って「1つのアイデア」であり、
  可能な限りアトミックになります。機能は、そのような多くのコミットで構成できます。
  
-機能フラグとインターフェイスの進化は、変更や長寿命の機能ブランチを壊すよりも優れています。
  
-書き込みではなく読み取り用に最適化します-その存続期間中、コードは書き込みよりもはるかに頻繁に読み取られます。
  小さなコミット、意味のあるコミットメッセージ、および有用なコメントにより、コードのレビューと改善が容易になります。
  コードレビューの品質とレビューの所要時間。小さな間違いを見つけるのははるかに簡単です、
  明確に定義された変更。

実地での展開に関するドキュメントは、
[wormhole-networks](https://github.com/certusone/wormhole-networks)リポジトリ。

## 投稿に関するFAQ

### \ <ランダムブロックチェーン\>を追加できますか？

答えは...多分？ワームホールのチェーンを完全にサポートするには、次のものが必要です。

-ワームホールのメインネットはDAOによって管理されています。ワームホールの設計は対称的です-すべてのガーディアンノードを実行する必要があります
  Wormholeがサポートするすべてのチェーンのノードまたはライトクライアント。これは合計され、新しいものをサポートするための障壁
  チェーンはかなり高いです。あなたの提案は、新しいチェーンをサポートすることの価値提案を明確に概説する必要があります。
  **チェーンのノードを実行するようにDAOを説得することは、新しいチェーンをサポートするための最初のステップです。**
  
-チェーンは、19個の個別のsecp256k1署名を検証できるスマートコントラクトをサポートする必要があります。

-スマートコントラクトを構築して監査する必要があります。場合によっては、既存の契約を使用できます。
  EVM互換チェーン。
  
-チェーンを監視するためのサポートをguardiandに追加する必要があります。

-実際にワームホールと対話するには、Webウォレットの統合を構築する必要があります。

難しい部分は、(1)DAOにノードを実行するように説得すること、および(2)コア開発チームに次のことを説得することです。
統合を構築するか、外部チームと協力して統合を構築します。

まず、GitHubの問題を開いて詳細を確認する必要があります。

<！-
TODO:DAOへの連絡方法は？今日のコミュニケーションのほとんどはテレグラムグループで行われているので、これを移動する必要があります
どこか公的な問い合わせに適しています(ディスコースフォーラム？)
->

### \ <ランダムブロックチェーンイノベーション\>をサポートしていますか？
多分 :-)。本質的に、ワームホールは一般的な認証メカニズムであり、特定の種類に結び付けられていません
コミュニケーションの(転送のような)。既存のワームホール契約を使用して、
ワームホール自体に変更を加えることなく、独自の機能を追加できます。

ユースケースの概要を説明するGitHubの問題を開いてください。そうすれば、私たちはあなたがそれを構築するのを手伝うことができます！

## レビューのために変更を送信する

Certus Oneは、[** forge.certus.one **](https://forge.certus.one)のコードレビューに** Gerrit **を使用します。 Gerritには
ブランチ全体をレビューするのではなく、個々のコミットのスタックを処理することの利点。これはそれを作ります
大きな機能を小さな断片に分割することでレビューがはるかに簡単になり、
意味のあるコミットメッセージでコミットをクリーンアップします。このワークフローは、より優れたソフトウェアを作成するのに役立ちます。

** GitHub PR **を介した投稿も受け付けていますが、Gerritを試してみることを強くお勧めします。 Gerritは持っています
多少の学習曲線ですが、はるかに優れたエクスペリエンスを提供します(Vimとメモ帳のように考えてください)。

GitHubリポジトリは、Gerritリポジトリのミラーです。 GitHubにはGitのグローバルCDNがあるため、計画している場合
ワームホールリポジトリを自動化された方法で大量に複製するには、GitHubから複製してください。

### なぜGerrit？

GitHubを使用して、レビュー対象の3つの変更A、B、Cを(この順序で)送信する場合は、2つあります。
選択肢:

-慎重にリベースされたコミットを含む単一のPRを送信し、レビュー担当者に実際に
  注意深く書かれたコミットメッセージと各コミットを個別に確認します。ただし、これは十分にサポートされていません
  UIによって、承認はスタック全体に対してのみ与えることができ、コミットのリベース/追加はそれを完全に破壊します。
  また、多くのプロジェクトで使用されているスカッシュマージポリシーでは機能しません。
  
-ベースの異なる3つの個別のPRを提出します。これにより、各変更を承認してマージできます
  個別に作成しますが、複数のブランチを手動でリベースする必要があり、煩わしいです。

GitHubは、変更を小さな部分に分割することを困難にすることで、大きくてレビューが難しい変更を推奨します。
Gerritの場合、その逆が当てはまります。**変更のスタックを送信するのは簡単です**。あなたはただ置くことができます
単一のブランチでA、B、およびCを変更します。

    C  <-- HEAD
    ↑
    B
    ↑
    A
    ↑
    O <-- origin/main, main
    ↑
    …

...そして単一の `git push origin HEAD:refs/for/main`を使用して3つすべてを送信します。 Gerritがレビューを作成します
A、B、Cを要求し、それらの間の関係チェーンを理解します。 Cは、Bと
C、およびCをマージすると、BとCも自動的にマージされます。

これは、BとCが完了する前に、Aをレビュー、承認、およびマージできることを意味します。その後、他のチームメンバーは
Aで構築を開始し、「大きな恐ろしいマージ」を回避します。このワークフローは、**トランクベースの開発**と呼ばれることがよくあります。

Gerritのその他の利点は次のとおりです。

-**変更のさまざまなバージョンを比較**する機能。インラインコメントが元の場所に表示されます。
  これは、変更を再確認するときに非常に役立ちます。
-リベース間でインラインコメントを保持します(！)。
-キーボードショートカットを使用して完全に駆動できる非常に応答性の高いユーザーインターフェイス。
  GitHubは遅くなる可能性があります。PRを開いて差分を表示するには、多くの場合、数秒かかります。
-開いているコメントの概要、そのステータス、および小さなコードスニペットを表示するビュー。
-コメントは、行全体だけでなく、選択範囲に添付できます。
  同じラインに複数のスレッドを接続できます。
-誰が行動を起こす必要があるかについてのきめ細かいステートマシンを備えた「**アテンションセット**」メカニズム、
  これにより、実行不可能な電子メール通知の送信が回避されます。
-私たちは独自のインフラストラクチャを運営しています。イェーイ地方分権！

### クイックスタート

Googleアカウントを使用してGerritにログインできます。 **会社を代表して貢献している場合は、
Gitのメールアドレスが所属を反映していることを確認してください！**

まず、[プロファイル設定](https://forge.certus.one/settings/#SSHKeys)のGerritにSSHキーを追加します。
または、HTTPパスワードを生成して、[Gitクレデンシャルストアの
選択](https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage)-これは特に便利です
SSHを使用したり、キーにアクセスしたりできない開発ホストまたは企業環境。

**まだ行っていない場合は、[リポジトリにアクセスして、Gerritからリポジトリのクローンを作成してください**
ページ](https://forge.certus.one/admin/repos/wormhole)および* "Clone with commit-msghook" *コマンドを使用します。もしも
変換したい既存のGitHubチェックアウトがあり、新しいリモコンを設定するだけで、次のようになります。
Gerritに初めてプッシュするときに、フックをインストールするように求められます。

    git remote set-url origin ssh://<gerrit-username>@[...]

次に、ローカルブランチにコミットします。 すべてのローカルコミットは、1つのコードレビューリクエストになります。 複数のコミット
同じブランチがスタックとして送信されます(上記を参照)。 完了したら、特別な参照にプッシュします
コードレビューを作成します:

    git push origin HEAD:refs/for/main

(該当する場合は、 `main`を別の開発ブランチに置き換えます)

それでおしまい！ 特別な工具は必要ありません。 これで、Web UIでコミットを確認し、レビュー担当者を追加できます。 もしも
タイピングを減らしたい場合は、次をご覧ください。

-クローンを作成できる優れた[IntelliJプラグイン](https://plugins.jetbrains.com/plugin/7272-gerrit)があります。
   IDE内からCLをチェックアウトし、レビューすることもできます。

-Goプロジェクトの[git-codereview](https://pkg.go.dev/golang.org/x/review/git-codereview)CLIユーティリティ。