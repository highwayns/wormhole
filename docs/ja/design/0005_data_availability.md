# 署名されたメッセージデータの可用性

【目次】

## 目的

接続されたチェーンに依存せずに、署名されたメッセージをワームホールクライアントが利用できるようにするため。

## バックグラウンド

ワームホールワークフローは通常、接続されたチェーンのいずれかでユーザーにトランザクションを送信させることから始まります。これにより、メッセージがチェーンに投稿されます。次に、このメッセージは保護者ネットワークによって取得および確認されます。十分な数の保護者が監視に署名したら、操作を完了するために、結果のメッセージ(署名されたVAA)をターゲットチェーンに投稿する必要があります。

Wormhole v1の設計では、データの可用性にSolanaを使用しています。保護者が十分な署名のあるVAAを観察するとすぐに、それをSolanaに送信するために競争し、そこで決定論的なアドレスを持つアカウントに保存されます。次に、クライアント(通常はWebウォレット)は、VAAのダイジェストに関する知識を使用して、同じ決定論的計算をシミュレートし、関連するSolanaアカウントからVAAを取得します。次に、クライアントはそれをターゲットチェーンに投稿し、ユーザーが料金を支払います。 Solanaでは、クライアント側の送信は必要ありません。データの可用性のために投稿されると、VAAはすぐに実行されます。

ただし、この設計は2つのチェーンのみをブリッジするv1には適していますが、v2には最適ではありません。

-不要な単一障害点が追加されます。 Solanaの停止は、無関係のチェーン間のトークン転送も防ぎます(理由からmainnet-betaと呼ばれます！)。また、メッセージには、Solanaがトランザクションを含めるのを待つ不要な余分な遅延が発生します。これを書いている時点では、これはメインネットベータのスキップ率が高いために悪化しており、トランザクションのかなりの割合が妥当な間隔内に含まれていません。

-それはSolanaのネットワークに余分な負担をかけます。特に、Solanaから*発信*されたメッセージの場合、ライトアンプリフィケーションが発生します。

-レースメカニズムは、規模が大きすぎてインセンティブを与えるのが難しいでしょう。プリフライトを使用できず、ノードが失敗したメッセージに対して不平等に支払うためです。リーダー選択メカニズムを実装する必要があります。

-ガーディアンノードは、ウォレット内で十分なSOLバランスを維持する必要があり、実際にトランザクションを送信するために報酬とインセンティブを与える必要があります。

-決定論的なSolanaアカウントのアドレスを再現することは、クライアント側で行うのは複雑です。

データの可用性要件では、実際にはメッセージを最終的なチェーンに投稿する必要はありません。便宜上、メッセージを使用しただけです。ガーディアンp2pネットワークからクライアントにバイトを確実にシャトルするものなら何でもうまくいき、オンチェーンストレージをより適切なカスタムメカニズムに置き換えることができます。

## 目標

-このメカニズムでは、クライアント(ネイティブ、アプリ、またはWeb)が、一意の(チェーン、エミッター、シーケンス)識別子で識別される特定のメッセージの署名付きVAAメッセージを待機して取得できるようにする必要があります。

-署名されたVAAは、少なくともメッセージがターゲットチェーンに投稿されるまで、クライアントが利用できる必要があります。理想的には、私たちの設計により、署名されたVAAのオプションの完全なアーカイブを維持できるようになります。

-設計のパフォーマンス特性は、すべてのネットワークがメッセージを最大容量で同時に公開し、メッセージあたり最大100〜200ミリ秒以内にすべてのネットワークからすべての署名付きVAAを永続化および取得するのに十分でなければなりません。

## 非目標

-この設計は、インセンティブを与えられたサードパーティがトランザクションをターゲットチェーンに送信するリレーメカニズムを容易にしますが、そのようなメカニズムがどのように実装されるかは指定されていません。

-保護者にパブリックAPIの実行を強制するインセンティブスキームを設計する。保護者ノードが高品質のAPIエンドポイントを実行するための効果的なインセンティブが提供されることを前提としています。

-クライアントによるパブリックAPIエンドポイントの検出。よく知られている負荷分散されたAPIフロントエンドのセットは、クライアントアプリケーションによって文書化され、ハードコーディングされると想定しています。

-サポートするインフラストラクチャの設計(スケーリング、キャッシング、負荷分散など)

-料金支払者の問題の解決-ユーザーは、クライアント側のメッセージ送信トランザクションの料金を支払うために、ターゲットチェーン上に既存のトークンが必要です。これは、そもそもトークンブリッジを使用してそのようなネイティブトークンを取得したいユーザーにとっては問題です。

-基盤となるゴシップネットワークのサービス拒否防止。

-非常に大きな状態(数十から数百GB)の最適化。

## 概要

署名されたVAAをSolanaに送信する代わりに、保護者はゴシップネットワークでそれらをブロードキャストし、署名されたVAAをローカルに保持します。

メッセージの監視に失敗した(したがってVAAを再構築できない)保護者は、ブロードキャストされた署名付きVAAを検証し、メッセージを監視したかのように保持します。

パブリックAPIエンドポイントがguardiandに追加され、クライアントが任意の(チェーン、エミッター、シーケンス)タプルの署名付きVAAを取得できるようにするAPIを公開します。保護者はこのAPIを使用して、Webウォレットやその他のクライアントが使用するパブリックで負荷分散されたパブリックサービスを提供できます。

(チェーン、エミッター)ごとのすべてのトランザクションはギャップのないシーケンス番号で順序付けられるため、既知のエミッターアドレスの有限セットに対して効率的な状態同期プロトコルを実装できます。ノードは、署名されたハートビートメッセージで各エミッタアドレスの最上位スロットを公開します。ノードは、ネットワークの大部分によって公開されたより高いスロット番号を監視するか、ギャップを監視することによって、欠落データに遭遇すると、ネットワーク上の他のノードにユニキャスト同期要求を送信し、欠落状態データの範囲を効率的にダウンロードできます。

既知のエミッタアドレスは、ノードソフトウェアにハードコーディングされています。このよく知られたリストに含まれていないエミッターは、引き続きプロトコルを使用できますが、データの可用性の保証は少なくなります。この初期設計では、このリストはプロトコル外のガバナンスプロセスの対象であり、将来的には適切なインセンティブを使用してオンチェーンガバナンスに移行できます。トークンブリッジのような一部のユースケースのみが、より強力なデータ可用性の恩恵を受けます。短期間の価格フィードのように、他のユースケースでは不要です。ノードは、これらの一時的なエミッターのローカルデータをプルーニングすることを選択できます。

ノードは非現在のガーディアンセットによって署名されたデータを信頼できないため、ガーディアンセットの境界を越えて状態を同期することはできません。

## 詳細設計

現在のguardiand実装は、ゴシップネットワークで完全な署名付きVAAをブロードキャストすることはなく、署名のみをブロードキャストします。次に、保護者は、独自のメッセージ監視と集約された署名のセットを使用して、有効な署名付きVAAをローカルでアセンブルします。シグニチャの2/3以上が存在すると、VAAは有効になり、ターゲットチェーンに送信できます。接続されたチェーンノードの問題が原因でメッセージを監視しなかったノードは、完全なVAAを構築できず、最終的には集約された署名のセットを削除します。

受信の順序とネットワークトポロジに応じて、2/3以上のしきい値を超えたときに表示される署名の集約セットは各ノードとは異なりますが、各ノードのVAAダイジェストは同じになります。

v1では、ノードはVAAを直接Solanaに送信し、フォールトトレランスと再試行のための複雑なロジックを使用します。最初に署名されたVAAはレースに「勝ち」、このメッセージの正規の署名されたVAAとしてチェーン上に保持されます。

代わりに、各ノードは完全に署名されたVAAをローカルに永続化し、ゴシップネットワークにブロードキャストします。ゴシップネットワークでは、保護ノードと、ゴシップネットワークに参加した非特権ノード(将来のリレーサービスなど)の両方で受信できます。

ローカルに永続化された状態は、ネットワーク全体でデータの可用性を維持するために重要です。これは、APIクエリ(有効な場合)を提供し、署名されたVAAを見逃した他の保護者に再ブロードキャストするために使用されます。

アトミックまたは信頼性の高いブロードキャストを提供するためにゴシップに依存することはできません。メッセージが失われたり、ノードがダウンしたりする可能性があります。ノードはすべてのローカル状態を失う可能性があり、また失われる可能性があり、パブリックAPIを提供するために使用されるノードを含め、メンテナンスのためにダウンすることを想定する必要があります。したがって、APIノードが欠落データを埋め戻すためのメカニズムが必要です。

(チェーン、エミッター、シーケンス)タプルをグローバル識別子として使用します。ダイジェストは、メッセージの公開時には不明であるため、グローバル識別子としては適していません。代わりに、すべてのコントラクトは、メッセージを公開するときに呼び出し元がシーケンス番号を利用できるようにし、呼び出し元はそれをクライアントに表示します。チェーンとエミッタのアドレスは静的です。

この設計では、ログメッセージやその他のユーザーおよびオペレーター向けのインターフェイスのメッセージのプライマリグローバル識別子としてのダイジェストの既存の使用法を廃止し、トラブルシューティングを支援します。このプレゼンテーション層の変更のみ-ダイジェストは引き続きリプレイ保護と署名検証に使用されます。

ガーディアン送信ステートマシンは、メモリ内ではなく、ローカルのKey-Valueストアで監視されたVAAの集約状態を維持するようにリファクタリングされます。これには、観察されたが不完全なVAAのタイムアウトを削除するという優れた副作用があり、欠落しているノードが復活したときに非同期で完了し、チェーン再生を使用して欠落しているブロックに追いつくことができます。

### 契約

スマートコントラクトに変更を加える必要はありません。

## 検討された代替案

### 状態同期ではなくプロバイダー側​​の冗長性

状態同期メカニズムを実装する代わりに、ゴシップネットワークをリッスンする複数のノードを実行することにより、VAAの完全な記録を維持することをAPIプロバイダーの責任にすることができます。

ノードは、単一の共有K/Vストア(BigtableやRedisなど)にべき等の書き込みを実行したり、クラスター内の他のノードに対してフォールスルーAPIリクエストを実行したり、LBレベルで再試行したりできます。

このような機能は、スケーラビリティを向上させるために将来実装される可能性がありますが、最初に状態同期を設計および実装することにしました。

-多くのノードに影響を与える可能性のあるゴシップメッセージの伝播の問題や操作上のミスを軽減したいと考えています。状態同期を使用すると、少なくとも1つのノードにコピーがある限り、メッセージを取得できます。

-分散化の理由から、複雑な外部依存関係や個別の障害ドメイン内の複数のノードを必要とせずに、単一のノードを使用して完全に機能するパブリックAPIを提供できるはずです。

### 直接P2P接続

libp2pはWebRTCトランスポートをサポートします。これにより、理論的には、Webウォレットが保護者のゴシップネットワークに直接参加できるようになります。ただし、このルートを追求しないことにしました。

--libp2pは非常に複雑であり、そのようなアプローチがどれほどうまく拡張できるかは明らかではありません。スケーラビリティ(またはその他の)の問題をデバッグするには、libp2pの詳細なデバッグが必要になる可能性がありますが、これは経験がありません。比較すると、従来のRPCスケールアウトアプローチに伴う課題ははるかによく理解されています。

-利用可能な唯一のリファレンス実装はNode.jsで記述されており、libp2p QUICトランスポートと[互換性がありません](https://github.com/libp2p/js-libp2p/issues/287)。メインのIPFSゴシップネットワークに参加して、パフォーマンスとセキュリティの問題となる既存のWebRTC対応ノードを利用するか、互換性のあるトランスポートのサポートを追加して、個別のブリッジノードを保護して実行する必要があります。

-クライアントはゴシップネットワークにメッセージを公開する必要があり、複雑なスパム防止メカニズムが必要になります。

ゴシップネットワークに直接接続することは、ネイティブのlibp2pQUICプロトコルを話すことができる中継器のような非Webクライアントの将来のための可能な設計のままです。 WebRTCトランスポートを使用した将来の実装でさえ、将来の開発のためのもっともらしい手段であり続けます。

## 警告

### 「リーチャーズ」

ノードが履歴状態を維持するための明示的なインセンティブは指定しません。ネットワークの大部分が(エフェメラルコンテナで実行するなどして)ローカル状態を適切に維持できない場合、他のノードに状態を提供するためにノードの数が不十分であることに依存するリスクがあります。

必要なストレージの量が少なく(VAAあたり約1KiB)、ノードに障害が発生した場合など、データの損失が発生することはまれであるため、現時点ではこれは問題ではないと考えています。状態同期プロトコルは、最初のゴシップ送信をリッスンするよりもはるかに遅く、APIオペレーターがメカニズムを誤用するインセンティブをほとんど提供しません。

### ゴシップパフォーマンス

この提案により、ゴシップネットワークを介してブロードキャストされるデータの量が大幅に増加し(署名付きメッセージのブロードキャストと状態の同期)、署名ブロードキャストの遅延とスループットに影響を与える可能性があります。状態同期のためのユニキャストlibp2p通信は、ヘッドオブラインブロッキングを引き起こし、コンセンサスに影響を与える可能性があります。

### 地方分権化の懸念

データの可用性にSolanaを使用すると、RPCサービスプロバイダーの確立されたエコシステムが付属します。この設計では、代わりに新しいAPIプロバイダーエコシステムを促進する必要があります。プロバイダーが少なすぎる場合、またはエコシステムが少数の大規模な独占者に集中している場合、それ以外の場合は信頼できない分散型システムで不要な集中化が発生する可能性があります。

代わりに、私たちの提案は分散化を改善すると信じています。SolanaRPCノードは、Solanaの非常に高いスループットと処理する必要のある大量の状態のために、運用に費用がかかり複雑です。対照的に、ワームホールのデータ可用性の問題は些細なことです。必要なのは、最終的に少なくとも1回は小さなキーと値のペアを配信することだけです。ワームホールRPCノードの提供とスケールアウトは、Solanaバリデーターを実行するよりもはるかに簡単なタスクです。つまり、より多くの関係者がそれらを提供できるようになります。この設計により、分散キーバリューストアに裏打ちされた自動スケーリングクラウドサービスを使用して、パブリックAPIを非常に簡単に実行できます。

## セキュリティに関する考慮事項

この提案は、すでに検証および署名されたデータのデータ可用性にのみ影響します。帯域内のデータ可用性メカニズムに障害が発生した場合は、帯域外の方法を使用してデータの可用性を確保できます(署名されたVAAを手動でフェッチして投稿するなど)。

### サービス拒否

ネットワーク上のすべてのノードが状態の同期を要求できるようにします。これは、ネットワークに対するサービス拒否攻撃に悪用される可能性があります。

レート制限とブラックリストのメカニズムを実装して、保護者がそのような攻撃に対応できるようにすることができます。

(これは、libp2p自体が非保護ノードによるpubsubフラッディングに対して安全であることを前提としています-これはhttps://github.com/certusone/wormhole/issues/22および[公式libp2pドキュメント](https://docs.libp2p.io/concepts/security-considerations/))。