# 签名消息数据可用性

[目录]

## 客观的

在不依赖连接的链的情况下，向 Wormhole 客户端提供签名消息。

## 背景

虫洞工作流通常首先让用户在任何连接的链上提交交易，这会导致一条消息被发布到链上。然后这个消息被监护人网络接收和确认。一旦有足够多的监护人签署了观察结果，生成的消息——签署的 VAA——需要发布到目标链以完成操作。

在 Wormhole v1 设计中，我们使用 Solana 来实现数据可用性。一旦任何监护人观察到具有足够签名的 VAA，它就会争先恐后地将其提交给 Solana，然后将其存储在具有确定性地址的帐户中。然后，客户端(通常是网络钱包)将使用其对 VAA 摘要的了解来模拟相同的确定性计算，并从其关联的 Solana 帐户中检索 VAA。客户端然后将其发布到目标链，费用由用户支付。在 Solana 上，不需要客户端提交——当发布数据可用性时，VAA 会立即执行。

然而，虽然这种设计对于仅桥接两条链的 v1 非常有效，但它对于 v2 并不是最佳的:

- 它增加了一个不必要的故障点。 Solana 中断还会阻止不相关链之间的代币转移(它被称为 mainnet-beta 是有原因的！)。消息还会导致等待 Solana 包含事务的不必要的额外延迟。在撰写本文时，高主网测试跳过率加剧了这种情况，这导致很大比例的交易未能包含在合理的间隔内。

- 它给 Solana 的网络带来了额外的压力。特别是，对于*源自*来自 Solana 的消息，它会导致写入放大。

- 竞争机制在规模上太昂贵并且难以激励，因为我们不能使用预检并且节点将为失败的消息付费，可能是不平等的。必须实施领导者选择机制。

- 监护人节点需要在他们的钱包中保持足够的 SOL 余额，并且需要得到补偿和激励以实际提交交易。

- 在客户端重现确定性的 Solana 帐户地址很复杂。

我们的数据可用性要求实际上并不要求将消息发布到最终链上——我们只是为了方便而使用了一个。任何能够可靠地将字节从守护者 p2p 网络传输到客户端的东西都可以解决问题，我们可以用更适合的自定义机制替换链上存储。

## 目标

- 该机制必须使任何客户端(本机、应用程序或 Web)能够等待并检索特定消息的签名 VAA 消息，该消息由其唯一(链、发射器、序列)标识符标识。

- 至少在消息发布到目标链之前，客户端必须可以使用签名的 VAA。理想情况下，我们的设计将能够维护一个可选的已签名 VAA 的完整存档。

- 设计的性能特征必须足以在每条消息最多 100-200 毫秒的时间内从所有网络持久保存和检索所有已签名的 VAA，并且所有网络以满负荷同时发布消息。

## 非目标

- 该设计促进了中继器机制，其中受激励的第三方将交易提交到目标链，但并未具体说明如何实施这种机制。

- 设计激励方案以强制监护人运行公共 API。我们假设为守护节点运行高质量的 API 端点提供了有效的激励。

- 客户端发现公共 API 端点。我们假设一组众所周知的负载平衡 API 前端将由客户端应用程序记录和硬编码。

- 支持基础设施的设计(扩展、缓存、负载平衡等)

- 解决费用支付者问题 - 用户需要目标链上现有的代币才能为客户端消息提交交易支付费用。对于想要首先使用令牌桥来获取此类原生令牌的用户来说，这是一个问题。

- 底层八卦网络的拒绝服务预防。

- 优化非常大的状态(几十到几百 GB)。

## 概述

监护人不是将签名的 VAA 提交给 Solana，而是在八卦网络上广播它们，并将签名的 VAA 保存在本地。

未能观察到消息(因此无法重建 VAA)的监护人将验证广播的签名 VAA 并将其保留，就像他们已经观察到一样。

一个公共 API 端点被添加到 Guardiand 中，公开一个 API，允许客户端检索任何(链、发射器、序列)元组的签名 VAA。监护人可以使用此 API 为网络钱包和其他客户端提供公共的、负载平衡的公共服务。

由于每个(链，发射器)的所有交易都是按无间隙序列号排序的，我们可以为一组有限的众所周知的发射器地址实现有效的状态同步协议。节点将在其签名的心跳消息中为每个发射器地址发布最高时隙。当一个节点遇到丢失的数据时，通过观察网络的大多数发布的更高时隙号或通过观察间隙，它可以向网络上的其他节点发送单播同步请求，并有效地下载丢失状态数据的范围。

众所周知的发射器地址被硬编码在节点软件中。不属于这个众所周知的列表的发射器仍然可以使用该协议，但具有较少的数据可用性保证。在这个初始设计中，此列表受协议外治理流程的约束，并且可以在未来通过适当的激励迁移到链上治理。只有像令牌桥这样的一些用例会从更强的数据可用性中受益——对于其他用例来说是不必要的，比如短期的价格馈送。节点可以选择为这些临时发射器修剪本地数据。

跨越监护人集边界的状态同步是不可能的，因为节点将无法信任由非当前监护人集签名的数据。

## 详细设计

当前的监护实现从未在八卦网络上广播完整的签名 VAA - 只有签名。监护人然后使用他们自己的消息观察和聚合的签名集在本地组装一个有效的签名 VAA。一旦超过 2/3 的签名出现，VAA 就有效并且可以提交给目标链。由于连接链节点的问题而未观察到消息的节点无法构建完整的 VAA，最终将丢弃聚合的签名集。

根据接收顺序和网络拓扑，跨 2/3+ 阈值时看到的聚合签名集与每个节点不同，但每个节点的 VAA 摘要将相同。

在 v1 中，节点将直接将 VAA 提交给 Solana，具有复杂的容错和重试逻辑。第一个签署的 VAA 将“赢得”一场比赛，并作为此消息的规范签署的 VAA 在链上持久化。

相反，每个节点现在都将在本地保存完整的签名 VAA 并将其广播到八卦网络，在那里它可以被加入八卦网络的监护人节点和非特权节点(如未来的中继服务)接收。

本地持久状态对于维持整个网络的数据可用性至关重要 - 它用于提供 API 查询(如果启用)并将签名的 VAA 重新广播给错过它们的其他监护人。

我们不能依赖 gossip 来提供原子或可靠的广播——消息可能会丢失，或者节点可能会宕机。我们需要假设节点可以并且将会丢失其所有本地状态，并且需要停机进行维护，包括用于提供公共 API 的节点。因此，我们需要一种 API 节点回填缺失数据的机制。

我们使用(链、发射器、序列)元组作为全局标识符。摘要不适合作为全局标识符，因为它在消息发布时是未知的。相反，所有合约在发布消息时都会向调用者提供序列号，然后调用者将其显示给客户端。链和发射器地址是静态的。

此设计弃用了将摘要作为日志消息和其他面向用户和操作员的界面中消息的主要全局标识符的现有用法，以帮助进行故障排除。这只是表示层的变化——摘要继续用于重放保护和签名验证。

监护提交状态机将被重构以在本地键值存储中而不是在内存中维护观察到的 VAA 的聚合状态。这有一个很好的副作用，即消除了观察到但不完整的 VAA 的超时，允许它们在丢失的节点被恢复时异步完成，并使用链重播来赶上丢失的块。

### 合同

无需更改智能合约。

## 考虑的替代方案

### 提供者端冗余而不是状态同步

我们可以代替实现状态同步机制，而是让 API 提供者负责通过运行多个节点来监听八卦网络来维护 VAA 的完整记录。

节点可以对单个共享 K/V 存储(如 Bigtable 或 Redis)执行幂等写入，对集群中的其他节点执行 fallthrough API 请求，或在 LB 级别重试。

虽然将来可能会实现这些功能以提高可扩展性，但我们决定首先设计和实现状态同步:

- 我们希望减轻可能影响许多节点的八卦消息传播问题或操作错误。通过状态同步，只要至少有一个节点有副本，就可以检索消息。

- 出于去中心化的原因，应该可以使用单个节点提供功能齐全的公共 API，而不需要复杂的外部依赖项或在单独的故障域中的多个节点。

### 直接 P2P 连接

libp2p 支持 WebRTC 传输，理论上这将允许网络钱包直接加入监护人八卦网络。但是，我们决定不走这条路:

- libp2p 非常复杂，目前尚不清楚这种方法的扩展性如何。调试任何可扩展性(或其他)问题可能需要深入的 libp2p 调试，我们没有这方面的经验。相比之下，传统 RPC 横向扩展方法带来的挑战更容易理解。

- 唯一可用的参考实现是用 Node.js 编写的，它与我们的 libp2p QUIC 传输[不兼容](https://github.com/libp2p/js-libp2p/issues/287)。我们要么必须加入主要的 IPFS gossip 网络以利用现有的支持 WebRTC 的节点，这将是一个性能和安全问题，要么添加对兼容传输的支持，以保护和运行单独的桥接节点。

- 客户端必须向八卦网络发布消息，并且需要复杂的垃圾邮件预防机制。

直接连接到 gossip 网络仍然是未来非 Web 客户端(例如可以使用本地 libp2p QUIC 协议的中继器)的一种可能设计。即使是使用 WebRTC 传输的未来实现仍然是未来发展的合理途径。

## 注意事项

### “吸血鬼”

我们没有为节点维护历史状态指定明确的激励措施。如果网络的很大一部分无法正确保持本地状态(例如通过在临时容器中运行)，我们就有可能依赖数量不足的节点来为其他人提供状态服务。

我们认为目前这不是问题，因为需要的存储量很小(每个 VAA 约 1KiB)并且数据丢失很少发生，例如节点发生故障时。状态同步协议比侦听最初的八卦传输慢得多，几乎没有激励 API 操作员滥用该机制。

### 八卦表演

该提议显着增加了通过八卦网络广播的数据量(签名消息广播和状态同步)，这可能会影响签名广播的延迟和吞吐量。用于状态同步的单播 libp2p 通信可能会导致队首阻塞并影响共识。

### 去中心化问题

使用 Solana 实现数据可用性附带了一个完善的 RPC 服务提供商生态系统。相反，这种设计需要促进新的 API 提供商生态系统。如果提供者太少，或者生态系统集中在几个大型垄断者身上，则可能会导致不必要的中心化，否则将导致去中心化的去信任化系统。

我们认为，我们的提议反而改进了去中心化:由于 Solana 的吞吐量非常高且需要处理大量状态，因此 Solana RPC 节点的操作既昂贵又复杂。相比之下，虫洞数据可用性问题是微不足道的——我们需要的只是最终至少一次交付小的键值对。服务和扩展 Wormhole RPC 节点比运行 Solana 验证器要容易得多，这意味着更多的参与方将能够提供它们。该设计使使用由任何分布式键值存储支持的自动缩放云服务运行公共 API 变得非常容易。

## 安全注意事项

此提案仅影响已验证和签名的数据的数据可用性。如果带内数据可用性机制失败，可以使用带外方法来确保数据可用性(例如手动获取和发布已签名的 VAA)。

### 拒绝服务

我们允许网络上的任何节点请求状态同步，这可能会被滥用于对网络的拒绝服务攻击。

可以实施限速和黑名单机制，使监护人能够应对此类攻击。

(这假设 libp2p 本身对于非监护节点的 pubsub 泛洪是安全的 - 这是在 https://github.com/certusone/wormhole/issues/22 以及 [official libp2p docs](https://docs.libp2p.io/concepts/security-conceptations/))。